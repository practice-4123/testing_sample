setInProgress(true);
    
    try {
        const fileList = await fetch(`http://aiws1:8081/chatbot/showsources?collection_name=${collectionName}`, { method: "POST" });
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const value = await fileList.json();
        setIndexFiles(value);
        setShowIndexedFile(true);
        console.log(showIndexedFile);
        setSelectedCollectionIndexFiles(indexFiles, collectionName);
    } catch (error) {
        // Handle any errors here
    } finally {
        setInProgress(false);
    }








{
    "version": "0.2.0",
    "configurations": [
      {
        "type": "node",
        "request": "launch",
        "name": "Debug Nest Framework",
        "runtimeExecutable": "npm",
        "runtimeArgs": [
          "run",
          "start:debug",
          "--",
          "--inspect-brk"
        ],
        "autoAttachChildProcesses": true,
        "restart": true,
        "sourceMaps": true,
        "stopOnEntry": false,
        "console": "integratedTerminal",
      }
    ]
  }

https://youtu.be/GurZKf5M154?si=phTq2x0sMNIkXZB9


I've few technologies that we have developed last year. And want to represent all these technologies as a tree form in my upcoming rangoli competition. So can you generate any good art of tree that represents all these technologies as a branch. It's just art rangoli.









private static void writeOutput(String inputPath, Map<String, String> piiResult) throws IOException {
        Files.write(Path.of(String.join(inputPath + "_out")), piiResult.entrySet().stream().map((entry) -> {
            try {
                return JSON.parse(entry.getValue());
            } catch (Exception ignore) {
                System.out.println("couldn't parse response for document: " + entry.getKey() + " value is:\n" + entry.getValue() + "-------");
                return entry.getValue();
            }
        }).collect(Collectors.joining(", ")).getBytes());
    }



String output = piiResult.entrySet().stream()
        .map(entry -> {
            String value = entry.getValue();
            // Fake "parse": check if it's likely JSON and return as-is or warn
            if (value.trim().startsWith("{") && value.trim().endsWith("}")) {
                return value; // looks like JSON, accept it
            } else {
                System.out.println("Couldn't parse response for document: " + entry.getKey() +
                    "\nValue is:\n" + value + "\n-------");
                return value; // fallback to raw value
            }
        })
        .collect(Collectors.joining(", "));

    Files.write(Path.of(inputPath + "_out"), output.getBytes());
